// Clinic Registry Script


module contracts.clinic_registry

type Did = ByteArray

type ClinicRecord = {
    approved_by: Did,
    approved_at: Time,
    revoked_at: Option<Time>
}

type ClinicRegistry = {
    clinics: Map<Did, ClinicRecord>,
    authority: Did
}

type RegistryError {
    Unauthorized { actor: Did }
    AlreadyRegistered { clinic: Did }
    NotRegistered { clinic: Did }
}

fn authorized(registry: ClinicRegistry, actor: Did) -> Bool {
    actor == registry.authority
}

fn add_clinic(
    registry: ClinicRegistry,
    actor: Did,
    clinic_did: Did,
    timestamp: Time,
) -> Result<ClinicRegistry, RegistryError> {
    if !authorized(registry, actor) {
        Error(Unauthorized { actor })
    } else {
        when registry.clinics.get(clinic_did) is {
            Some(record) ->
                when record.revoked_at is {
                    None ->
                        Error(AlreadyRegistered { clinic: clinic_did })

                    Some(_) ->
                        let new_record = record {
                            approved_by: actor,
                            approved_at: timestamp,
                            revoked_at: None
                        }

                        Ok(
                            registry {
                                clinics: registry.clinics.insert(clinic_did, new_record)
                            },
                        )
                }

            None ->
                let new_record = ClinicRecord {
                    approved_by: actor,
                    approved_at: timestamp,
                    revoked_at: None
                }

                Ok(
                    registry {
                        clinics: registry.clinics.insert(clinic_did, new_record)
                    },
                )
        }
    }
}

fn revoke_clinic(
    registry: ClinicRegistry,
    actor: Did,
    clinic_did: Did,
    timestamp: Time,
) -> Result<ClinicRegistry, RegistryError> {
    if !authorized(registry, actor) {
        Error(Unauthorized { actor })
    } else {
        when registry.clinics.get(clinic_did) is {
            Some(record) ->
                let updated = registry.clinics.insert(
                    clinic_did,
                    record { revoked_at: Some(timestamp) },
                )

                Ok(registry { clinics: updated })

            None ->
                Error(NotRegistered { clinic: clinic_did })
        }
    }
}

fn reinstate_clinic(
    registry: ClinicRegistry,
    actor: Did,
    clinic_did: Did,
    timestamp: Time,
) -> Result<ClinicRegistry, RegistryError> {
    if !authorized(registry, actor) {
        Error(Unauthorized { actor })
    } else {
        when registry.clinics.get(clinic_did) is {
            Some(record) ->
                when record.revoked_at is {
                    Some(_) ->
                        let reinstated = record {
                            approved_by: actor,
                            approved_at: timestamp,
                            revoked_at: None
                        }

                        Ok(
                            registry {
                                clinics: registry.clinics.insert(clinic_did, reinstated)
                            },
                        )

                    None ->
                        Ok(registry)
                }

            None ->
                Error(NotRegistered { clinic: clinic_did })
        }
    }
}

fn transfer_authority(
    registry: ClinicRegistry,
    actor: Did,
    new_authority: Did,
) -> Result<ClinicRegistry, RegistryError> {
    if !authorized(registry, actor) {
        Error(Unauthorized { actor })
    } else {
        Ok(registry { authority: new_authority })
    }
}

fn is_registered(
    registry: ClinicRegistry,
    clinic_did: Did,
    reference_time: Time,
) -> Bool {
    when registry.clinics.get(clinic_did) is {
        Some(record) ->
            reference_time >= record.approved_at
                && when record.revoked_at is {
                    Some(_) -> false
                    None -> true
                }

        None ->
            false
    }
}

fn next_review_due(registry: ClinicRegistry, clinic_did: Did, interval: Time) -> Option<Time> {
    when registry.clinics.get(clinic_did) is {
        Some(record) ->
            when record.revoked_at is {
                Some(_) -> None
                None -> Some(record.approved_at + interval)
            }

        None ->
            None
    }
}