// On-Chain Anchor Service


module contracts.on_chain_anchor

type Did = ByteArray

type Anchor = {
    data_hash: Hash,
    did: Did,
    timestamp: Time,
    expires_at: Option<Time>
}

type AnchorError {
    HashMismatch { expected: Hash, actual: Hash }
    DidMismatch { expected: Did, actual: Did }
    Expired { at: Time }
    InvalidExpiry { expires_at: Time, timestamp: Time }
}

fn create_anchor(
    data_hash: Hash,
    did: Did,
    timestamp: Time,
    expires_at: Option<Time>,
) -> Result<Anchor, AnchorError> {
    when expires_at is {
        Some(expiry) ->
            if expiry <= timestamp {
                Error(InvalidExpiry { expires_at: expiry, timestamp })
            } else {
                Ok(Anchor { data_hash, did, timestamp, expires_at })
            }

        None ->
            Ok(Anchor { data_hash, did, timestamp, expires_at })
    }
}

fn verify_anchor_hash(anchor: Anchor, expected_hash: Hash) -> Result<(), AnchorError> {
    if anchor.data_hash == expected_hash {
        Ok(())
    } else {
        Error(HashMismatch { expected: expected_hash, actual: anchor.data_hash })
    }
}

fn verify_anchor_did(anchor: Anchor, expected_did: Did) -> Result<(), AnchorError> {
    if anchor.did == expected_did {
        Ok(())
    } else {
        Error(DidMismatch { expected: expected_did, actual: anchor.did })
    }
}

fn assert_anchor_fresh(anchor: Anchor, current_time: Time) -> Result<(), AnchorError> {
    when anchor.expires_at is {
        Some(expiry) ->
            if current_time <= expiry {
                Ok(())
            } else {
                Error(Expired { at: current_time })
            }

        None ->
            Ok(())
    }
}

fn verify_anchor(
    anchor: Anchor,
    expected_hash: Hash,
    expected_did: Did,
    current_time: Time,
) -> Result<(), AnchorError> {
    verify_anchor_hash(anchor, expected_hash)?;
    verify_anchor_did(anchor, expected_did)?;
    assert_anchor_fresh(anchor, current_time)?;
    Ok(())
}